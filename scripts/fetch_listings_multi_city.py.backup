#!/usr/bin/env python3
"""
[STEP 1] Fetch listings from multiple cities based on cities_config.json

This script queries the RentFaster API for each enabled city and combines results.
Uses Selenium to bypass Cloudflare protection.

Reads: cities_config.json
Outputs: rentfaster_listings.json
"""

import json
import time
from pathlib import Path
from datetime import datetime
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from webdriver_manager.chrome import ChromeDriverManager
from concurrent.futures import ThreadPoolExecutor, as_completed
import threading
import argparse

def load_cities_config():
    """Load cities configuration"""
    config_file = Path("cities_config.json")
    
    if not config_file.exists():
        print("âŒ cities_config.json not found!")
        return []
    
    with open(config_file, 'r', encoding='utf-8') as f:
        config = json.load(f)
    
    enabled_cities = [city for city in config.get('cities', []) if city.get('enabled', False)]
    enabled_cities.sort(key=lambda x: x.get('priority', 999))
    
    return enabled_cities

stats_lock = threading.Lock()
city_stats = {}

def fetch_city_listings(city_config, driver, is_first_city, max_pages=200, worker_id=0):
    """Fetch listings for a specific city using Selenium to bypass Cloudflare"""
    print(f"[Worker {worker_id}] ğŸ“ Fetching listings for {city_config['name']}...")
    
    all_listings = []
    page = 1
    max_pages = 200  # Safety limit
    
    while page <= max_pages:
        try:
            # Build API URL with query parameters
            # Some cities (like Toronto) use city_id instead of keywords
            if 'city_id' in city_config:
                url = (f"https://www.rentfaster.ca/api/search.json?"
                       f"city_id={city_config['city_id']}&"
                       f"cur_page={page}&"
                       f"type=&"  # All types
                       f"beds=")  # All bedrooms
            else:
                url = (f"https://www.rentfaster.ca/api/search.json?"
                       f"proximity_type=location-city&"
                       f"cur_page={page}&"
                       f"type=&"  # All types
                       f"beds=&"  # All bedrooms
                       f"keywords={city_config['city_code']}")
            
            print(f"   Page {page}...", end='', flush=True)
            
            # Load the page
            driver.get(url)
            
            # Wait for Cloudflare challenge on first page of first city
            # Subsequent pages/cities load faster
            if page == 1 and is_first_city:
                print(f" [Worker {worker_id}] (waiting 15s for Cloudflare)...", end='', flush=True)
                time.sleep(15)
            else:
                time.sleep(3)
            
            # Get the JSON response from the page
            page_text = driver.find_element(By.TAG_NAME, 'body').text
            data = json.loads(page_text)
            
            listings = data.get('listings', [])
            
            if not listings:
                print(f" âœ“ (empty, done)")
                break
            
            # Add city info to each listing
            for listing in listings:
                listing['city_code'] = city_config['city_code']
                listing['province_code'] = city_config['province_code']
            
            all_listings.extend(listings)
            print(f" âœ“ ({len(listings)} listings)")
            
            page += 1
            
        except json.JSONDecodeError as e:
            print(f" âŒ JSON Error: {e}")
            break
        except Exception as e:
            print(f" âŒ Unexpected error: {e}")
            break
    
    print(f"   Total: {len(all_listings):,} listings from {city_config['name']}")
    return all_listings

def main():
    print("=" * 80)
    print("ğŸŒ RENTFASTER MULTI-CITY LISTINGS FETCHER")
    print("=" * 80)
    
    # Load configuration
    enabled_cities = load_cities_config()
    
    if not enabled_cities:
        print("\nâŒ No cities enabled in cities_config.json")
        print("   Edit the file and set 'enabled: true' for at least one city")
        return
    
    print(f"\nğŸ“‹ Enabled cities: {', '.join(c['name'] for c in enabled_cities)}")
    print(f"   Total: {len(enabled_cities)} cities")
    
    # Setup Selenium Chrome driver
    print(f"\nğŸŒ Setting up Chrome browser...")
    chrome_options = Options()
    # NOTE: Must use visible browser - headless mode is detected by Cloudflare
    chrome_options.add_argument('--disable-blink-features=AutomationControlled')
    chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
    chrome_options.add_experimental_option('useAutomationExtension', False)
    chrome_options.add_argument('--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36')
    
    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service, options=chrome_options)
    
    # Hide webdriver property (helps bypass Cloudflare detection)
    driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
    
    try:
        # Fetch listings for each city
        all_listings = []
        city_stats = {}
        
        for idx, city in enumerate(enabled_cities):
            is_first_city = (idx == 0)
            city_listings = fetch_city_listings(city, driver, is_first_city)
            all_listings.extend(city_listings)
            city_stats[city['name']] = len(city_listings)
    
    finally:
        # Always close the browser
        print(f"\nğŸŒ Closing browser...")
        driver.quit()
    
    # Remove duplicates by ref_id (in case of overlaps)
    print(f"\nğŸ” Removing duplicates...")
    seen = set()
    unique_listings = []
    for listing in all_listings:
        ref_id = listing.get('ref_id')
        if ref_id and ref_id not in seen:
            seen.add(ref_id)
            unique_listings.append(listing)
    
    duplicates_removed = len(all_listings) - len(unique_listings)
    if duplicates_removed > 0:
        print(f"   Removed {duplicates_removed:,} duplicate listings")
    
    # Save to file
    output_file = 'rentfaster_listings.json'
    print(f"\nğŸ’¾ Saving to {output_file}...")
    
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(unique_listings, f, ensure_ascii=False, indent=2)
    
    # Print summary
    print("\n" + "=" * 80)
    print("âœ… FETCH COMPLETE!")
    print("=" * 80)
    print(f"\nğŸ“Š Summary by City:")
    for city_name, count in city_stats.items():
        print(f"   {city_name:15s}: {count:5,} listings")
    print(f"   {'â”€' * 23}")
    print(f"   {'Total (unique)':15s}: {len(unique_listings):5,} listings")
    print(f"\nğŸ“ Saved to: {output_file}")
    print(f"â° Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("\nğŸ’¡ Next step: Run download_raw_html_parallel.py to download HTML files")
    print("=" * 80)

if __name__ == "__main__":
    main()
